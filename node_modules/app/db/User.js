var mongoose = require('app/db/mongoose_connect.js');
var Schema = mongoose.Schema;
var ObjectId = Schema.Types.ObjectId;

var IDGeneratorHelper = require('app/helpers/IDGeneratorHelper.js');
var Globals = require('app/helpers/Globals.js');
var onesignal = require('node-opensignal-api');
var onesignal_client = onesignal.createClient();
var passport = require('passport');
var bcrypt = require('bcrypt');

var SALT_LENGTH  = 10;

var customSchema = new Schema({
        uuid: {type: String, required: true, index: true},
        secret_key : {type: String, default: "", index:true},
        zipcode: {type: String, required: true},
        notification_time: {type: String},
        last_notification_date : {type: Date},
        onesignal_id : {type: String},
        push_tokens : [{os: String, token: String}],
        notifications_enabled : {type: Boolean, default: false}
    },
    {timestamps: {createdAt: 'dateCreated', updatedAt: 'dateUpdated'}}
);

customSchema.virtual('').get(function () {
});


customSchema.pre("save", function (next) {
    next();
});

customSchema.post("init", function (doc) {

});

customSchema.methods.generateSecretKey = function(callback){
    var user = this;

    var id_callback = function(err, secret_key){
        if (err){
            console.log(err);
            callback(err);
        }
        //create salt
        bcrypt.genSalt(SALT_LENGTH, function(err1, salt) {
            if (err1) {
                console.log("Error creating salt");
                return callback(err1);
            }

            //use salt to hash password
            bcrypt.hash(secret_key, salt, function (err2, hashed_secret_key) {
                if (err2) {
                    console.log("Error generating password hash()");
                    return callback(err2);
                }

                user.secret_key = hashed_secret_key;
                user.save(function(err3, _user){
                   if(err3){
                       console.log(err3);
                       callback(err3);
                   }
                    else{
                       callback(null, secret_key, _user);
                   }
                });
            });
        });
    };

    IDGeneratorHelper.generateUniqueId("User", "secret_key", this, null, {length : 20, callback: id_callback});
};

//customSchema.pre("validate", function(next) {
//    if (!this.secret_key){
//        var user = this;
//
//        var callback = function(err, secret_key){
//            if (err){
//                console.log(err);
//                next(err);
//            }
//            //create salt
//            bcrypt.genSalt(SALT_LENGTH, function(err, salt) {
//                if (err) {
//                    console.log("Error creating salt");
//                    return next(err);
//                }
//
//                //use salt to hash password
//                bcrypt.hash(secret_key, salt, function (err, hashed_secret_key) {
//                    if (err) {
//                        console.log("Error generating password hash()");
//                        return next(err);
//                    }
//
//                    user.secret_key = hashed_secret_key;
//                    next();
//                });
//            });
//        };
//
//        IDGeneratorHelper.generateUniqueId("User", "secret_key", this, null, {length : 20});
//    }
//    else next();
//});

customSchema.statics.createUser = function(uuid, zipcode, callback){
  var new_user = new this({
      "uuid" : uuid,
      "zipcode" : zipcode
  });

    new_user.generateSecretKey(function(err, secret_key, _user){
       if(err){
           console.log(err);
           callback(err, null, null);
       }
        else{
           console.log("User created: " + _user + " with secret key: " + secret_key);
           callback(null, secret_key, _user);
       }
    });
};

customSchema.statics.sendPushNotifications = function(users, title, message){
    var onesignal_ids = [];
    users.forEach(function(user){
        if(user.notifications_enabled && user.onesignal_id){
            onesignal_ids.push(user.onesignal_id);
        }
    });

    var params = {
        app_id: process.env.ONESIGNAL_APP_ID,
        contents: {
            'en': message
        },
        headings: {
            'en' : title
        },
        ios_badgeType: "Increase",
        ios_badgeCount: 1,
        include_player_ids: onesignal_ids
    };

    onesignal_client.notifications.create(process.env.ONESIGNAL_API_KEY, params, function (err, response) {
        if (err) {
            console.log('Onesignal error:', err);
        } else {
            users.forEach(function(user){
                user.last_notification_date = Date.now();
                user.save();
            });
            console.log(response);
        }
    });
};

customSchema.methods.sendPushNotification = function(title, message){
    mongoose.model("User").sendPushNotifications([this], title, message);
};

customSchema.statics.authenticateUser = function(req, res, next, callback){
    var user = req.body.user ? req.body.user : req.body;

    if (!user){
        return callback("No params", null);
    }

    var secret_key = user.secret_key;
    var uuid = user.uuid;

    if (uuid && secret_key) {
        passport.authenticate('uuid-secretkey', function(err, userFound, info){
            if (err){
                console.log("Error fetching user " + err);
                return callback(err, null);
            }
            else if (!userFound) {
                return callback(null, null);
            }
            else {
                console.log("User found " + userFound.userId);
                return callback(null, userFound);
            }
        })(req, res, next);

    }
    else {
        return callback("Params are null", null);
    }
};






customSchema.methods.validateSecretKey = function(secret_key, callback){
    bcrypt.compare(secret_key, this.secret_key, callback);
};


module.exports = mongoose.model('User', customSchema);