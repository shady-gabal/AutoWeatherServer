var mongoose = require('app/db/mongoose_connect.js');
var Schema = mongoose.Schema;
var ObjectId = Schema.Types.ObjectId;

var IDGeneratorHelper = require('app/helpers/IDGeneratorHelper.js');
var Globals = require('app/helpers/Globals.js');
var passport = require('passport');
var bcrypt = require('bcrypt');
var SALT_LENGTH  = 10;
var moment = require('moment');
var OneSignal = require('app/helpers/OneSignal.js');

var customSchema = new Schema({
        uuid: {type: String, required: true, index: true},
        secret_key : {type: String, default: "", index:true},
        zipcode: {type: String, required: true},
        country : {type: String},
        degrees : {type: String, enum: ["f", "c"]},
        notification_time: {type: String},
        last_notification_date : {type: Date},
        onesignal_ids : [{type: String}],
        push_tokens : [{os: String, token: String}],
        notifications_enabled : {type: Boolean, default: true},
        timezone : {type: String}
    },
    {timestamps: {createdAt: 'dateCreated', updatedAt: 'dateUpdated'}}
);

customSchema.virtual('').get(function () {
});


customSchema.pre("save", function (next) {
    next();
});

customSchema.post("init", function (doc) {

});

customSchema.methods.generateSecretKey = function(callback, options){
    var user = this;
    options = options ? options : {};

    var id_callback = function(err, secret_key){
        if (err){
            console.log(err);
            callback(err);
        }
        //create salt
        bcrypt.genSalt(SALT_LENGTH, function(err1, salt) {
            if (err1) {
                console.log("Error creating salt");
                return callback(err1);
            }

            //use salt to hash password
            bcrypt.hash(secret_key, salt, function (err2, hashed_secret_key) {
                if (err2) {
                    console.log("Error generating password hash()");
                    return callback(err2);
                }

                user.secret_key = hashed_secret_key;

                if (!options.dont_save) {
                    user.save(function(err3, _user){
                        if(err3){
                            console.log(err3);
                            callback(err3);
                        }
                        else{
                            callback(null, secret_key, _user);
                        }
                    });
                }
                else{
                    callback(null, secret_key, user);
                }

            });
        });
    };

    IDGeneratorHelper.generateUniqueId("User", "secret_key", this, null, {length : 20, callback: id_callback});
};

customSchema.statics.createUser = function(data, callback){
    var User = this;

    var shouldAddToQueue = false;
    var uuid = data.uuid;

    var createUserFunc = function(){
        var new_user = new User({
            uuid : uuid
        });

        new_user.generateSecretKey(function(err, secret_key, _user){
            if(err){
                console.log(err);
                callback(err, null, null);
            }
            else{
                _user.updateWithData(data, function(err2){
                    console.log("User created: " + _user + " with secret key: " + secret_key);

                    callback(err2, secret_key, _user);

                    if (shouldAddToQueue && data.zipcode){
                        mongoose.model("WeatherAtZipcode").createWithZipcode(data.zipcode);
                    }
                });

            }
        }, {dont_save: true});

    };

    var zipcode = data.zipcode;
    mongoose.model("WeatherAtZipcode").findOne({"zipcode" : zipcode}).count(function(err, count){
       if (!err && count == 0) {
           shouldAddToQueue = true;
       }
        createUserFunc()
    });
};


customSchema.statics.sendPushNotifications = function(users, title, message){
    var onesignal_ids = [];
    users.forEach(function(user){
        if(user.notifications_enabled && user.onesignal_ids && user.onesignal_ids.length > 0){
            onesignal_ids = onesignal_ids.concat(user.onesignal_ids);
        }
    });

    if (onesignal_ids.length > 0){
        OneSignal.sendPushNotification(onesignal_ids, title, message, function (err, response) {
            if (err || response["errors"]) {
                err = err ? err : response["errors"][0];
                console.log('Onesignal error:', err);
            } else {
                users.forEach(function(user){
                    user.last_notification_date = Date.now();
                    user.save();
                });
                console.log(response);
            }
        });
    }
};

customSchema.methods.sendPushNotification = function(title, message){
    mongoose.model("User").sendPushNotifications([this], title, message);
};

customSchema.statics.authenticateUser = function(req, res, next, callback){
    var user = req.body.user ? req.body.user : req.body;

    if (!user){
        return callback("No params", null);
    }

    var secret_key = user.secret_key;
    var uuid = user.uuid;

    if (uuid && secret_key) {
        passport.authenticate('uuid-secretkey', function(err, userFound, info){
            if (err){
                console.log("Error fetching user " + err);
                return callback(err, null);
            }
            else if (!userFound) {
                return callback(null, null);
            }
            else {
                console.log("User found " + userFound.userId);
                return callback(null, userFound);
            }
        })(req, res, next);

    }
    else {
        return callback("Params are null", null);
    }
};


customSchema.methods.updateWithData = function(data, callback){
    var user = this;

    var zipcode = data.zipcode;
    var onesignal_id = data.onesignal_id;
    var notification_time = data.notification_time;
    var seconds_from_utc = data.seconds_from_utc ? data.seconds_from_utc : 0;
    var os = data.os;
    var push_token = data.push_token;
    var country = data.country;

    if (zipcode) {
        this.zipcode = zipcode;
    }
    if (country){
        this.country = country;
    }
    if (notification_time) {
        //convert to UTC
        var date = moment(notification_time, "hh:mm A").toDate();
        var utc_date = date - (seconds_from_utc * 1000);
        var utc_time = Globals.notificationTimeFromDate(utc_date);
        this.notification_time = utc_time;
    }

    if (onesignal_id && this.onesignal_ids.indexOf(onesignal_id) == -1){
        this.onesignal_ids.push(onesignal_id);
    }

    if (push_token){
        var currToken = this.push_tokens.find(function(token){
            return token === push_token;
        });

        if (os && !currToken){
            user.push_tokens.push({os: os, push_token: push_token});
        }
    }

    user.save(callback);
}



customSchema.methods.validateSecretKey = function(secret_key, callback){
    bcrypt.compare(secret_key, this.secret_key, callback);
};


module.exports = mongoose.model('User', customSchema);