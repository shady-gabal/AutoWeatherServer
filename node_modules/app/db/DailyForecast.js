var mongoose = require('app/db/mongoose_connect.js');
var mongoose = require('app/db/mongoose_connect.js');
var Schema = mongoose.Schema;
var ObjectId = Schema.Types.ObjectId;
var Globals = require('app/helpers/Globals.js');

var customSchema = new Schema({
        maxtemp_f: {type: String},
        maxtemp_c : {type: String},
        mintemp_f : {type: String},
        mintemp_c : {type: String},
        avgtemp_f : {type: String},
        avgtemp_c : {type: String},
        condition: {type: String},
        icon : {type: String},
        will_it_rain : {type: Boolean},
        will_it_snow : {type: Boolean},
        rain_start_time: {type: String, default: -1},
        //rain_end_time: {type: String, default: -1},
        snow_start_time: {type: String, default: -1},
        //snow_end_time: {type: String, default: -1},
        //location_city: {type: String},
        //location_region: {type: String},
        units: {type: String},
        timezone : {type: String},
        lat : {type: Number},
        lon : {type: Number},
        hourly_forecasts : [{hour : Number, temp: Number, rain: Boolean, snow: Boolean}]
    },
    {timestamps: {createdAt: 'dateCreated', updatedAt: 'dateUpdated'}}
);

customSchema.virtual('maxtemp').get(function () {
    return this.units === "us" ? this.maxtemp_f : this.maxtemp_c;
});

customSchema.virtual('mintemp').get(function () {
    return this.units === "us" ? this.mintemp_f : this.mintemp_c;
});

customSchema.virtual('unitType').get(function () {
    return this.units === "us" ? "f" : "c";
});


customSchema.pre("save", function (next) {
    next();
});

customSchema.post("init", function (doc) {

});

customSchema.statics.withJson = function(json){
  var dailyForecast = new this({
      lat : json["latitude"],
      lon : json["longitude"],
      timezone : json["timezone"],
      units : json["flags"]["units"]
   });

    return dailyForecast;
};

customSchema.statics.forecastForLocation = function(lat, lon, callback){
    var url = "https://api.darksky.net/forecast/" + process.env.DARKSKY_API_KEY + "/" + lat + "," + lon + "?units=auto";

    console.log(url);

    var DailyForecast = this;

    Globals.requestUrl(url, function(err, json){

        if (err){
            callback(err, null);
        }
        else if (json["error"]){
            console.log(json["error"]);
            callback(json["error"], null);
        }
        else{
            //console.log("updating weather with " + JSON.stringify(json));

            //rain start, snow start
            var hourly = json["hourly"]["data"];
            var rainStartTime = -1, snowStartTime = -1;

            var dailyForecast = DailyForecast.withJson(json);

            var day = json["daily"]["data"][0];
            var maxtemp = day["temperatureMax"], mintemp = day["temperatureMin"], avgtemp = 0;

            var updateHour = Globals.weatherUpdateHour();
            var maxIndex = 24 - updateHour;

            for (var i = 0; i < maxIndex; i++){
                var hour = hourly[i];
                var temp = hour["temperature"];
                var rain = false, snow = false;
                var currHour = i + updateHour;

                avgtemp += temp;

                if (hour["precipProbability"] >= Globals.MIN_PRECIP_PROBABILITY && hour["precipType"] == "rain"){
                    rain = true;
                    if (rainStartTime == -1) {
                        rainStartTime = currHour;
                    }
                }
                if (hour["precipProbability"] >= Globals.MIN_PRECIP_PROBABILITY && hour["precipType"] == "snow"){
                    snow = true;
                    if (snowStartTime == -1) {
                        snowStartTime = currHour;
                    }
                }

                var hourlyForecast = {hour: currHour, temp: temp, rain: rain, snow: snow};
                dailyForecast.hourly_forecasts.push(hourlyForecast);
            }

            avgtemp /= maxIndex;

            dailyForecast.will_it_rain = rainStartTime != -1;
            dailyForecast.rain_start_time = rainStartTime;
            dailyForecast.will_it_snow = snowStartTime != -1;
            dailyForecast.snow_start_time = snowStartTime;

            if (dailyForecast.units == "us") {
                dailyForecast.maxtemp_f = maxtemp;
                dailyForecast.mintemp_f = mintemp;
                dailyForecast.maxtemp_c = Globals.convertToCelsius(maxtemp);
                dailyForecast.mintemp_c = Globals.convertToCelsius(mintemp);
                dailyForecast.avgtemp_f = avgtemp;
                dailyForecast.avgtemp_c = Globals.convertToCelsius(avgtemp);
            }
            else {
                dailyForecast.maxtemp_c = maxtemp;
                dailyForecast.mintemp_c = mintemp;
                dailyForecast.maxtemp_f = Globals.convertToFahrenheit(maxtemp);
                dailyForecast.mintemp_f = Globals.convertToFahrenheit(mintemp);
                dailyForecast.avgtemp_c = avgtemp;
                dailyForecast.avgtemp_f = Globals.convertToFahrenheit(avgtemp);
            }


            dailyForecast.save();

            //console.log("updated dailyforecast: " + dailyForecast);

            callback(null, dailyForecast);
        }
    }, {errorCatchMessage : "Not Found"});
};

//customSchema.statics.currentWeatherForZipcode = function(zipcode, callback){
//    var url = "https://api.apixu.com/v1/current.json?key=" + process.env.APIXU_API_KEY + "&q=" + zipcode;
//    Globals.requestUrl(url, callback);
//};

customSchema.statics.forecastWithData = function(data, callback){

    var forecast = new this({

    });

    forecast.save(function(err, _forecast){
       if(err){
           console.log(err);
           callback(err, null);
       }
        else{
           //console.log("created forecast: " + _forecast);
           callback(null, _forecast);
       }
    });
};


module.exports = mongoose.model('DailyForecast', customSchema);